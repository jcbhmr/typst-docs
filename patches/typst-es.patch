diff --git a/.gitignore b/.gitignore
index 6b7bb4e5..c17c6399 100644
--- a/.gitignore
+++ b/.gitignore
@@ -28,6 +28,3 @@ package-lock.json
 # Nix
 /result
 .direnv/
-
-# typst-docs output
-_site
diff --git a/crates/typst-docs/Cargo.toml b/crates/typst-docs/Cargo.toml
index bb32aaf2..7b444b9b 100644
--- a/crates/typst-docs/Cargo.toml
+++ b/crates/typst-docs/Cargo.toml
@@ -10,13 +10,6 @@ publish = false
 doctest = false
 bench = false
 
-[[bin]]
-name = "typst-docs"
-required-features = ["cli"]
-
-[features]
-cli = ["clap", "typst-render", "serde_json"]
-
 [dependencies]
 typst = { workspace = true }
 comemo = { workspace = true }
@@ -32,9 +25,6 @@ typed-arena = { workspace = true }
 unicode_names2 = { workspace = true }
 unscanny = { workspace = true }
 yaml-front-matter = { workspace = true }
-clap = { workspace = true, optional = true }
-typst-render = { workspace = true, optional = true }
-serde_json = { workspace = true, optional = true }
 
 [lints]
 workspace = true
diff --git a/crates/typst-docs/src/html.rs b/crates/typst-docs/src/html.rs
index 956aca76..8f6d1366 100644
--- a/crates/typst-docs/src/html.rs
+++ b/crates/typst-docs/src/html.rs
@@ -45,12 +45,7 @@ impl Html {
 
     /// Convert markdown to HTML.
     #[track_caller]
-    pub fn markdown(
-        resolver: &dyn Resolver,
-        md: &str,
-        nesting: Option<usize>,
-        base: &str,
-    ) -> Self {
+    pub fn markdown(resolver: &dyn Resolver, md: &str, nesting: Option<usize>) -> Self {
         let mut text = md;
         let mut description = None;
         let document = YamlFrontMatter::parse::<Metadata>(md);
@@ -65,7 +60,7 @@ impl Html {
             | md::Options::ENABLE_HEADING_ATTRIBUTES;
 
         let ids = Arena::new();
-        let mut handler = Handler::new(text, resolver, nesting, &ids, base);
+        let mut handler = Handler::new(text, resolver, nesting, &ids);
         let mut events = md::Parser::new_ext(text, options).peekable();
         let iter = std::iter::from_fn(|| loop {
             let mut event = events.next()?;
@@ -144,7 +139,6 @@ struct Handler<'a> {
     outline: Vec<OutlineItem>,
     nesting: Option<usize>,
     ids: &'a Arena<String>,
-    base: &'a str,
 }
 
 impl<'a> Handler<'a> {
@@ -153,7 +147,6 @@ impl<'a> Handler<'a> {
         resolver: &'a dyn Resolver,
         nesting: Option<usize>,
         ids: &'a Arena<String>,
-        base: &'a str,
     ) -> Self {
         Self {
             text,
@@ -164,7 +157,6 @@ impl<'a> Handler<'a> {
             outline: vec![],
             nesting,
             ids,
-            base,
         }
     }
 
@@ -315,7 +307,7 @@ impl<'a> Handler<'a> {
             return Ok(link);
         }
 
-        crate::link::resolve(link, self.base)
+        crate::link::resolve(link)
     }
 
     fn nesting(&self) -> usize {
diff --git a/crates/typst-docs/src/lib.rs b/crates/typst-docs/src/lib.rs
index fbda7ec3..f2531462 100644
--- a/crates/typst-docs/src/lib.rs
+++ b/crates/typst-docs/src/lib.rs
@@ -77,16 +77,15 @@ static FONTS: Lazy<(Prehashed<FontBook>, Vec<Font>)> = Lazy::new(|| {
 
 /// Build documentation pages.
 pub fn provide(resolver: &dyn Resolver) -> Vec<PageModel> {
-    let base = resolver.base().unwrap_or("/docs/");
     vec![
-        markdown_page(resolver, base, "overview.md", base).with_route(base),
-        tutorial_pages(resolver, base),
-        reference_pages(resolver, base),
-        guide_pages(resolver, base),
-        packages_page(resolver, base),
-        markdown_page(resolver, base, "changelog.md", base),
-        markdown_page(resolver, base, "roadmap.md", base),
-        markdown_page(resolver, base, "community.md", base),
+        markdown_page(resolver, "/docs/", "overview.md").with_route("/docs/"),
+        tutorial_pages(resolver),
+        reference_pages(resolver),
+        guide_pages(resolver),
+        packages_page(resolver),
+        markdown_page(resolver, "/docs/", "changelog.md"),
+        markdown_page(resolver, "/docs/", "roadmap.md"),
+        markdown_page(resolver, "/docs/", "community.md"),
     ]
 }
 
@@ -103,9 +102,6 @@ pub trait Resolver {
 
     /// Determine the commits between two tags.
     fn commits(&self, from: &str, to: &str) -> Vec<Commit>;
-
-    /// Get the base URL for the routes and links.
-    fn base(&self) -> Option<&str>;
 }
 
 /// Create a page from a markdown file.
@@ -114,11 +110,10 @@ fn markdown_page(
     resolver: &dyn Resolver,
     parent: &str,
     path: impl AsRef<Path>,
-    base: &str,
 ) -> PageModel {
     assert!(parent.starts_with('/') && parent.ends_with('/'));
     let md = DOCS_DIR.get_file(path).unwrap().contents_utf8().unwrap();
-    let html = Html::markdown(resolver, md, Some(0), base);
+    let html = Html::markdown(resolver, md, Some(0));
     let title: EcoString = html.title().expect("chapter lacks a title").into();
     PageModel {
         route: eco_format!("{parent}{}/", urlify(&title)),
@@ -132,93 +127,71 @@ fn markdown_page(
 }
 
 /// Build the tutorial.
-fn tutorial_pages(resolver: &dyn Resolver, base: &str) -> PageModel {
-    let mut page = markdown_page(resolver, base, "tutorial/welcome.md", base);
+fn tutorial_pages(resolver: &dyn Resolver) -> PageModel {
+    let mut page = markdown_page(resolver, "/docs/", "tutorial/welcome.md");
     page.children = DOCS_DIR
         .get_dir("tutorial")
         .unwrap()
         .files()
         .filter(|file| file.path() != Path::new("tutorial/welcome.md"))
-        .map(|file| {
-            markdown_page(resolver, &format!("{base}tutorial/"), file.path(), base)
-        })
+        .map(|file| markdown_page(resolver, "/docs/tutorial/", file.path()))
         .collect();
     page
 }
 
 /// Build the reference.
-fn reference_pages(resolver: &dyn Resolver, base: &str) -> PageModel {
-    let mut page = markdown_page(resolver, base, "reference/welcome.md", base);
+fn reference_pages(resolver: &dyn Resolver) -> PageModel {
+    let mut page = markdown_page(resolver, "/docs/", "reference/welcome.md");
     page.children = vec![
-        markdown_page(
-            resolver,
-            &format!("{base}reference/"),
-            "reference/syntax.md",
-            base,
-        )
-        .with_part("Language"),
-        markdown_page(
-            resolver,
-            &format!("{base}reference/"),
-            "reference/styling.md",
-            base,
-        ),
-        markdown_page(
-            resolver,
-            &format!("{base}reference/"),
-            "reference/scripting.md",
-            base,
-        ),
-        category_page(resolver, FOUNDATIONS, base).with_part("Library"),
-        category_page(resolver, MODEL, base),
-        category_page(resolver, TEXT, base),
-        category_page(resolver, MATH, base),
-        category_page(resolver, SYMBOLS, base),
-        category_page(resolver, LAYOUT, base),
-        category_page(resolver, VISUALIZE, base),
-        category_page(resolver, INTROSPECTION, base),
-        category_page(resolver, DATA_LOADING, base),
+        markdown_page(resolver, "/docs/reference/", "reference/syntax.md")
+            .with_part("Language"),
+        markdown_page(resolver, "/docs/reference/", "reference/styling.md"),
+        markdown_page(resolver, "/docs/reference/", "reference/scripting.md"),
+        category_page(resolver, FOUNDATIONS).with_part("Library"),
+        category_page(resolver, MODEL),
+        category_page(resolver, TEXT),
+        category_page(resolver, MATH),
+        category_page(resolver, SYMBOLS),
+        category_page(resolver, LAYOUT),
+        category_page(resolver, VISUALIZE),
+        category_page(resolver, INTROSPECTION),
+        category_page(resolver, DATA_LOADING),
     ];
     page
 }
 
 /// Build the guides section.
-fn guide_pages(resolver: &dyn Resolver, base: &str) -> PageModel {
-    let mut page = markdown_page(resolver, base, "guides/welcome.md", base);
+fn guide_pages(resolver: &dyn Resolver) -> PageModel {
+    let mut page = markdown_page(resolver, "/docs/", "guides/welcome.md");
     page.children = vec![
-        markdown_page(
-            resolver,
-            &format!("{base}guides/"),
-            "guides/guide-for-latex-users.md",
-            base,
-        ),
-        markdown_page(resolver, &format!("{base}guides/"), "guides/page-setup.md", base),
+        markdown_page(resolver, "/docs/guides/", "guides/guide-for-latex-users.md"),
+        markdown_page(resolver, "/docs/guides/", "guides/page-setup.md"),
     ];
     page
 }
 
 /// Build the packages section.
-fn packages_page(resolver: &dyn Resolver, base: &str) -> PageModel {
+fn packages_page(resolver: &dyn Resolver) -> PageModel {
     let md = DOCS_DIR
         .get_file("reference/packages.md")
         .unwrap()
         .contents_utf8()
         .unwrap();
     PageModel {
-        route: eco_format!("{}packages/", base),
+        route: "/docs/packages/".into(),
         title: "Packages".into(),
         description: "Packages for Typst.".into(),
         part: None,
         outline: vec![],
-        body: BodyModel::Packages(Html::markdown(resolver, md, Some(1), base)),
+        body: BodyModel::Packages(Html::markdown(resolver, md, Some(1))),
         children: vec![],
     }
 }
 
 /// Create a page for a category.
 #[track_caller]
-fn category_page(resolver: &dyn Resolver, category: Category, base: &str) -> PageModel {
-    let route = eco_format!("{}reference/{}/", base, category.name());
+fn category_page(resolver: &dyn Resolver, category: Category) -> PageModel {
+    let route = eco_format!("/docs/reference/{}/", category.name());
     let mut children = vec![];
     let mut items = vec![];
     let mut shorthands = None;
@@ -234,7 +207,7 @@ fn category_page(resolver: &dyn Resolver, category: Category, base: &str) -> Pag
     // Add groups.
     for group in GROUPS.iter().filter(|g| g.category == category.name()).cloned() {
         if matches!(group.name.as_str(), "sym" | "emoji") {
-            let subpage = symbols_page(resolver, &route, &group, base);
+            let subpage = symbols_page(resolver, &route, &group);
             let BodyModel::Symbols(model) = &subpage.body else { continue };
             let list = &model.list;
             markup.extend(
@@ -256,7 +229,7 @@ fn category_page(resolver: &dyn Resolver, category: Category, base: &str) -> Pag
             continue;
         }
 
-        let (child, item) = group_page(resolver, &route, &group, base);
+        let (child, item) = group_page(resolver, &route, &group);
         children.push(child);
         items.push(item);
     }
@@ -289,7 +262,7 @@ fn category_page(resolver: &dyn Resolver, category: Category, base: &str) -> Pag
             Value::Func(func) => {
                 let name = func.name().unwrap();
 
-                let subpage = func_page(resolver, &route, func, path, base);
+                let subpage = func_page(resolver, &route, func, path);
                 items.push(CategoryItem {
                     name: name.into(),
                     route: subpage.route.clone(),
@@ -299,7 +272,7 @@ fn category_page(resolver: &dyn Resolver, category: Category, base: &str) -> Pag
                 children.push(subpage);
             }
             Value::Type(ty) => {
-                let subpage = type_page(resolver, &route, ty, base);
+                let subpage = type_page(resolver, &route, ty);
                 items.push(CategoryItem {
                     name: ty.short_name().into(),
                     route: subpage.route.clone(),
@@ -318,7 +291,7 @@ fn category_page(resolver: &dyn Resolver, category: Category, base: &str) -> Pag
     }
 
     let name = category.title();
-    let details = Html::markdown(resolver, category.docs(), Some(1), base);
+    let details = Html::markdown(resolver, category.docs(), Some(1));
     let mut outline = vec![OutlineItem::from_name("Summary")];
     outline.extend(details.outline());
     outline.push(OutlineItem::from_name("Definitions"));
@@ -351,9 +324,8 @@ fn func_page(
     parent: &str,
     func: &Func,
     path: &[&str],
-    base: &str,
 ) -> PageModel {
-    let model = func_model(resolver, func, path, false, base);
+    let model = func_model(resolver, func, path, false);
     let name = func.name().unwrap();
     PageModel {
         route: eco_format!("{parent}{}/", urlify(name)),
@@ -372,7 +344,6 @@ fn func_model(
     func: &Func,
     path: &[&str],
     nested: bool,
-    base: &str,
 ) -> FuncModel {
     let name = func.name().unwrap();
     let scope = func.scope().unwrap();
@@ -386,7 +357,7 @@ fn func_model(
     }
 
     let mut returns = vec![];
-    casts(resolver, &mut returns, &mut vec![], func.returns().unwrap(), base);
+    casts(resolver, &mut returns, &mut vec![], func.returns().unwrap());
     returns.sort_by_key(|ty| type_index(ty));
     if returns == ["none"] {
         returns.clear();
@@ -403,25 +374,22 @@ fn func_model(
         keywords: func.keywords(),
         oneliner: oneliner(details),
         element: func.element().is_some(),
-        details: Html::markdown(resolver, details, nesting, base),
-        example: example.map(|md| Html::markdown(resolver, md, None, base)),
+        details: Html::markdown(resolver, details, nesting),
+        example: example.map(|md| Html::markdown(resolver, md, None)),
         self_,
-        params: params
-            .iter()
-            .map(|param| param_model(resolver, param, base))
-            .collect(),
+        params: params.iter().map(|param| param_model(resolver, param)).collect(),
         returns,
-        scope: scope_models(resolver, name, scope, base),
+        scope: scope_models(resolver, name, scope),
     }
 }
 
 /// Produce a parameter's model.
-fn param_model(resolver: &dyn Resolver, info: &ParamInfo, base: &str) -> ParamModel {
+fn param_model(resolver: &dyn Resolver, info: &ParamInfo) -> ParamModel {
     let (details, example) = split_details_and_example(info.docs);
 
     let mut types = vec![];
     let mut strings = vec![];
-    casts(resolver, &mut types, &mut strings, &info.input, base);
+    casts(resolver, &mut types, &mut strings, &info.input);
     if !strings.is_empty() && !types.contains(&"str") {
         types.push("str");
     }
@@ -429,8 +397,8 @@ fn param_model(resolver: &dyn Resolver, info: &ParamInfo, base: &str) -> ParamMo
 
     ParamModel {
         name: info.name,
-        details: Html::markdown(resolver, details, None, base),
-        example: example.map(|md| Html::markdown(resolver, md, None, base)),
+        details: Html::markdown(resolver, details, None),
+        example: example.map(|md| Html::markdown(resolver, md, None)),
         types,
         strings,
         default: info.default.map(|default| {
@@ -465,36 +433,30 @@ fn casts(
     types: &mut Vec<&'static str>,
     strings: &mut Vec<StrParam>,
     info: &CastInfo,
-    base: &str,
 ) {
     match info {
         CastInfo::Any => types.push("any"),
         CastInfo::Value(Value::Str(string), docs) => strings.push(StrParam {
             string: string.clone().into(),
-            details: Html::markdown(resolver, docs, None, base),
+            details: Html::markdown(resolver, docs, None),
         }),
         CastInfo::Value(..) => {}
         CastInfo::Type(ty) => types.push(ty.short_name()),
         CastInfo::Union(options) => {
             for option in options {
-                casts(resolver, types, strings, option, base);
+                casts(resolver, types, strings, option);
             }
         }
     }
 }
 
 /// Produce models for a function's scope.
-fn scope_models(
-    resolver: &dyn Resolver,
-    name: &str,
-    scope: &Scope,
-    base: &str,
-) -> Vec<FuncModel> {
+fn scope_models(resolver: &dyn Resolver, name: &str, scope: &Scope) -> Vec<FuncModel> {
     scope
         .iter()
         .filter_map(|(_, value)| {
             let Value::Func(func) = value else { return None };
-            Some(func_model(resolver, func, &[name], true, base))
+            Some(func_model(resolver, func, &[name], true))
         })
         .collect()
 }
@@ -560,20 +522,19 @@ fn group_page(
     resolver: &dyn Resolver,
     parent: &str,
     group: &GroupData,
-    base: &str,
 ) -> (PageModel, CategoryItem) {
     let mut functions = vec![];
     let mut outline = vec![OutlineItem::from_name("Summary")];
 
     let path: Vec<_> = group.path.iter().map(|s| s.as_str()).collect();
-    let details = Html::markdown(resolver, &group.details, Some(1), base);
+    let details = Html::markdown(resolver, &group.details, Some(1));
     outline.extend(details.outline());
 
     let mut outline_items = vec![];
     for name in &group.filter {
         let value = group.module().scope().get(name).unwrap();
         let Value::Func(func) = value else { panic!("not a function") };
-        let func = func_model(resolver, func, &path, true, base);
+        let func = func_model(resolver, func, &path, true);
         let id_base = urlify(&eco_format!("functions-{}", func.name));
         let children = func_outline(&func, &id_base);
         outline_items.push(OutlineItem {
@@ -616,8 +577,8 @@ fn group_page(
 }
 
 /// Create a page for a type.
-fn type_page(resolver: &dyn Resolver, parent: &str, ty: &Type, base: &str) -> PageModel {
-    let model = type_model(resolver, ty, base);
+fn type_page(resolver: &dyn Resolver, parent: &str, ty: &Type) -> PageModel {
+    let model = type_model(resolver, ty);
     PageModel {
         route: eco_format!("{parent}{}/", urlify(ty.short_name())),
         title: ty.title().into(),
@@ -630,18 +591,18 @@ fn type_page(resolver: &dyn Resolver, parent: &str, ty: &Type, base: &str) -> Pa
 }
 
 /// Produce a type's model.
-fn type_model(resolver: &dyn Resolver, ty: &Type, base: &str) -> TypeModel {
+fn type_model(resolver: &dyn Resolver, ty: &Type) -> TypeModel {
     TypeModel {
         name: ty.short_name(),
         title: ty.title(),
         keywords: ty.keywords(),
         oneliner: oneliner(ty.docs()),
-        details: Html::markdown(resolver, ty.docs(), Some(1), base),
+        details: Html::markdown(resolver, ty.docs(), Some(1)),
         constructor: ty
             .constructor()
             .ok()
-            .map(|func| func_model(resolver, &func, &[], true, base)),
-        scope: scope_models(resolver, ty.short_name(), ty.scope(), base),
+            .map(|func| func_model(resolver, &func, &[], true)),
+        scope: scope_models(resolver, ty.short_name(), ty.scope()),
     }
 }
 
@@ -663,13 +624,8 @@ fn type_outline(model: &TypeModel) -> Vec<OutlineItem> {
 }
 
 /// Create a page for symbols.
-fn symbols_page(
-    resolver: &dyn Resolver,
-    parent: &str,
-    group: &GroupData,
-    base: &str,
-) -> PageModel {
-    let model = symbols_model(resolver, group, base);
+fn symbols_page(resolver: &dyn Resolver, parent: &str, group: &GroupData) -> PageModel {
+    let model = symbols_model(resolver, group);
     PageModel {
         route: eco_format!("{parent}{}/", group.name),
         title: group.title.clone(),
@@ -682,7 +638,7 @@ fn symbols_page(
 }
 
 /// Produce a symbol list's model.
-fn symbols_model(resolver: &dyn Resolver, group: &GroupData, base: &str) -> SymbolsModel {
+fn symbols_model(resolver: &dyn Resolver, group: &GroupData) -> SymbolsModel {
     let mut list = vec![];
     for (name, value) in group.module().scope().iter() {
         let Value::Symbol(symbol) = value else { continue };
@@ -719,7 +675,7 @@ fn symbols_model(resolver: &dyn Resolver, group: &GroupData, base: &str) -> Symb
     SymbolsModel {
         name: group.name.clone(),
         title: group.title.clone(),
-        details: Html::markdown(resolver, &group.details, Some(1), base),
+        details: Html::markdown(resolver, &group.details, Some(1)),
         list,
     }
 }
@@ -845,9 +801,5 @@ mod tests {
         fn commits(&self, _: &str, _: &str) -> Vec<Commit> {
             vec![]
         }
-
-        fn base(&self) -> Option<&str> {
-            None
-        }
     }
 }
diff --git a/crates/typst-docs/src/link.rs b/crates/typst-docs/src/link.rs
index 20a4f6e4..e7e191fe 100644
--- a/crates/typst-docs/src/link.rs
+++ b/crates/typst-docs/src/link.rs
@@ -4,15 +4,15 @@ use typst::foundations::Func;
 use crate::{get_module, GROUPS, LIBRARY};
 
 /// Resolve an intra-doc link.
-pub fn resolve(link: &str, base: &str) -> StrResult<String> {
+pub fn resolve(link: &str) -> StrResult<String> {
     if link.starts_with('#') || link.starts_with("http") {
         return Ok(link.to_string());
     }
 
     let (head, tail) = split_link(link)?;
-    let mut route = match resolve_known(head, base) {
-        Some(route) => route,
-        None => resolve_definition(head, base)?,
+    let mut route = match resolve_known(head) {
+        Some(route) => route.into(),
+        None => resolve_definition(head)?,
     };
 
     if !tail.is_empty() {
@@ -35,24 +35,24 @@ fn split_link(link: &str) -> StrResult<(&str, &str)> {
 }
 
 /// Resolve a `$` link head to a known destination.
-fn resolve_known(head: &str, base: &str) -> Option<String> {
+fn resolve_known(head: &str) -> Option<&'static str> {
     Some(match head {
-        "$tutorial" => format!("{base}tutorial"),
-        "$reference" => format!("{base}reference"),
-        "$category" => format!("{base}reference"),
-        "$syntax" => format!("{base}reference/syntax"),
-        "$styling" => format!("{base}reference/styling"),
-        "$scripting" => format!("{base}reference/scripting"),
-        "$guides" => format!("{base}guides"),
-        "$packages" => format!("{base}packages"),
-        "$changelog" => format!("{base}changelog"),
-        "$community" => format!("{base}community"),
+        "$tutorial" => "/docs/tutorial",
+        "$reference" => "/docs/reference",
+        "$category" => "/docs/reference",
+        "$syntax" => "/docs/reference/syntax",
+        "$styling" => "/docs/reference/styling",
+        "$scripting" => "/docs/reference/scripting",
+        "$guides" => "/docs/guides",
+        "$packages" => "/docs/packages",
+        "$changelog" => "/docs/changelog",
+        "$community" => "/docs/community",
         _ => return None,
     })
 }
 
 /// Resolve a `$` link to a global definition.
-fn resolve_definition(head: &str, base: &str) -> StrResult<String> {
+fn resolve_definition(head: &str) -> StrResult<String> {
     let mut parts = head.trim_start_matches('$').split('.').peekable();
     let mut focus = &LIBRARY.global;
     let mut category = None;
@@ -76,8 +76,8 @@ fn resolve_definition(head: &str, base: &str) -> StrResult<String> {
         group.category == category.name() && group.filter.iter().any(|func| func == name)
     }) {
         let mut route = format!(
-            "{}reference/{}/{}/#functions-{}",
-            base, group.category, group.name, name
+            "/docs/reference/{}/{}/#functions-{}",
+            group.category, group.name, name
         );
         if let Some(param) = parts.next() {
             route.push('-');
@@ -86,7 +86,7 @@ fn resolve_definition(head: &str, base: &str) -> StrResult<String> {
         return Ok(route);
     }
 
-    let mut route = format!("{}reference/{}/{name}/", base, category.name());
+    let mut route = format!("/docs/reference/{}/{name}/", category.name());
     if let Some(next) = parts.next() {
         if value.field(next).is_ok() {
             route.push_str("#definitions-");
diff --git a/crates/typst-docs/src/main.rs b/crates/typst-docs/src/main.rs
deleted file mode 100644
index 90136a99..00000000
--- a/crates/typst-docs/src/main.rs
+++ /dev/null
@@ -1,127 +0,0 @@
-use std::fs;
-use std::path::{Path, PathBuf};
-
-use clap::Parser;
-use typst::model::Document;
-use typst::visualize::Color;
-use typst_docs::{provide, Html, Resolver};
-use typst_render::render;
-
-struct MyResolver<'a> {
-    assets_dir: &'a Path,
-    verbose: bool,
-    base: &'a str,
-}
-
-impl<'a> Resolver for MyResolver<'a> {
-    fn commits(&self, from: &str, to: &str) -> Vec<typst_docs::Commit> {
-        if self.verbose {
-            eprintln!("commits({from}, {to})");
-        }
-        vec![]
-    }
-
-    fn example(
-        &self,
-        hash: u128,
-        source: Option<Html>,
-        document: &Document,
-    ) -> typst_docs::Html {
-        if self.verbose {
-            eprintln!(
-                "example(0x{hash:x}, {:?} chars, Document)",
-                source.as_ref().map(|s| s.as_str().len())
-            );
-        }
-
-        let frame = &document.pages.first().expect("page 0").frame;
-        let pixmap = render(frame, 2.0, Color::WHITE);
-        let filename = format!("{hash:x}.png");
-        let path = self.assets_dir.join(&filename);
-        fs::create_dir_all(path.parent().expect("parent")).expect("create dir");
-        pixmap.save_png(path.as_path()).expect("save png");
-        let src = format!("/assets/{filename}");
-        eprintln!("Generated example image {path:?}");
-
-        if let Some(code) = source {
-            let code_safe = code.as_str();
-            Html::new(format!(
-                r#"<div class="previewed-code"><pre>{code_safe}</pre><div class="preview"><img src="{src}" alt="Preview" /></div></div>"#
-            ))
-        } else {
-            Html::new(format!(
-                r#"<div class="preview"><img src="{src}" alt="Preview" /></div>"#
-            ))
-        }
-    }
-
-    fn image(&self, filename: &str, data: &[u8]) -> String {
-        if self.verbose {
-            eprintln!("image({filename}, {} bytes)", data.len());
-        }
-
-        let path = self.assets_dir.join(filename);
-        fs::create_dir_all(path.parent().expect("parent")).expect("create dir");
-        fs::write(&path, data).expect("write image");
-        eprintln!("Created {} byte image at {path:?}", data.len());
-
-        format!("/assets/{filename}")
-    }
-
-    fn link(&self, link: &str) -> Option<String> {
-        if self.verbose {
-            eprintln!("link({link})");
-        }
-        None
-    }
-
-    fn base(&self) -> Option<&str> {
-        Some(self.base)
-    }
-}
-
-/// Generates the JSON representation of the documentation. This can be used to
-/// generate the HTML yourself. You are encouraged to post-process the generated
-/// JSON to rewrite links and other things to match your site's structure. Be
-/// warned: the JSON structure is not stable and may change at any time.
-#[derive(Parser, Debug)]
-#[command(version, about, long_about = None)]
-struct Args {
-    /// The generation process can produce additional assets. Namely images.
-    /// This option controls where to spit them out. The HTML generation will
-    /// assume that this output directory is served at `/assets/*`. All
-    /// generated HTML references will use `/assets/image5.png` or similar.
-    /// Files will be written to this directory like `${assets_dir}/image5.png`.
-    #[arg(long, default_value = "assets")]
-    assets_dir: PathBuf,
-
-    /// Controls the base URL or pathname of the generated documentation. This
-    /// can be a complete URL like `https://example.org/docs/` or a pathname
-    /// like `/docs/`. This is used to generate the cross-page links in the HTML
-    /// as well as the `page.route` field assigned to each page in the output
-    /// JSON. This field does not support `./` but does support `/`. If it does
-    /// not end with `/` then `/` will be appended.
-    #[arg(long, default_value = "/")]
-    base: String,
-
-    /// Enable verbose logging. This will print out all the calls to the
-    /// resolver and the paths of the generated assets.
-    #[arg(long)]
-    verbose: bool,
-}
-
-fn main() -> Result<(), Box<dyn std::error::Error>> {
-    let args = Args::parse();
-
-    let root_pages = provide(&MyResolver {
-        assets_dir: args.assets_dir.as_path(),
-        verbose: args.verbose,
-        base: &args.base,
-    });
-    eprintln!("Be warned: the JSON structure is not stable and may change at any time.");
-    let json = serde_json::to_string_pretty(&root_pages)?;
-    println!("{json}");
-
-    eprintln!("All done!");
-    Ok(())
-}
